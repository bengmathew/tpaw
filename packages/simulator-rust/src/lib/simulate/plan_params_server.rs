#![allow(non_camel_case_types)]

// Ideally we would use the types generated by the protobuf compiler directly,
// but:
// 1. The lack of "required" in proto3 means there will be a lot of Option<T>s,
//    that will have to be unwrapped. (not relevant - switched to proto2 for
//    required).
// 2. Even if we switch to proto2 and use required fields, oneof (aka enum)
//    field cannot be made required, so we will have this indirection anyway.
// 3. Enum value types (like strategy) show up as i32 in the generated code, we
//    we have to map them to the correct type.
// 4. It allows us to have a clear boundary for converting types like an i64 that
//    that represents a rounded float on wire, to a f64.
// 5. Names generated by the protobuf compiler are not in the style of the rest
//    of our code

use std::{convert::TryFrom, ops::RangeInclusive};
use crate::wire::*;

// ------- UTILS -------

pub type LogF64 = WireLogDouble;
pub type ScaleLogF64= WireScaleLogDouble;
pub type PlanParamsServer_GlidePath_Intermediate = WireGlidePathIntermediate;
pub type PlanParamsServer_GlidePath = WireGlidePath;

pub type PlanParamsServer_AmountNotTimed = WirePlanParamsServerAmountNotTimed;

pub type PlanParamsServer_AmountTimed_DeltaEveryRecurrence =
    wire_plan_params_server_amount_timed::DeltaEveryRecurrence;

impl From<WireInt32Range> for RangeInclusive<i32> {
    fn from(wire: WireInt32Range) -> Self {
        wire.start..=wire.end
    }
}

#[derive(Debug, Clone)]
pub struct PlanParamsServer_AmountTimed {
    pub id: String,
    pub is_nominal: bool,
    pub month_range: Option<RangeInclusive<i32>>,
    pub valid_month_range: RangeInclusive<i32>,
    pub every_x_months: i32,
    pub base_amount: f64,
    pub delta_every_recurrence: PlanParamsServer_AmountTimed_DeltaEveryRecurrence,
}

impl From<WirePlanParamsServerAmountTimed> for PlanParamsServer_AmountTimed {
    fn from(wire: WirePlanParamsServerAmountTimed) -> Self {
        Self {
            id: wire.id,
            is_nominal: wire.is_nominal,
            month_range: wire.month_range.map(|x| x.into()),
            valid_month_range: wire.valid_month_range.into(),
            every_x_months: wire.every_x_months,
            base_amount: wire.base_amount,
            delta_every_recurrence: wire.delta_every_recurrence.unwrap(),
        }
    }
}

// ------- CONSTANTS -------
pub type PlanParamsServer_Constants  = WirePlanParamsServerConstants;

// ------- AGES -------
pub type PlanParamsServer_Ages_SimulationMonths =  WirePlanParamsServerAgesSimulationMonths;
impl PlanParamsServer_Ages_SimulationMonths {
    pub fn last_month(&self) -> u32 {
        self.num_months - 1
    }
    pub fn num_withdrawal_months(&self) -> u32 {
        self.num_months - self.withdrawal_start_month
    }
}

pub type PlanParamsServer_Ages_Person = WirePlanParamsServerAgesPerson;
pub type PlanParamsServer_Ages = WirePlanParamsServerAges;

// ------- WEALTH -------

#[derive(Debug, Clone)]
pub enum PlanParamsServer_PortfolioBalance {
    UpdatedHere(f64),
    NotUpdatedHere{updated_at_id:String, updated_to:f64, updated_at_timestamp_ms:i64},
}

impl From<wire_plan_params_server_wealth::PortfolioBalance> for PlanParamsServer_PortfolioBalance {
    fn from(wire: wire_plan_params_server_wealth::PortfolioBalance) -> Self {
        match wire {
            wire_plan_params_server_wealth::PortfolioBalance::UpdatedHere(updated_to) => Self::UpdatedHere(updated_to as f64),
            wire_plan_params_server_wealth::PortfolioBalance::NotUpdatedHere(updated_at) => Self::NotUpdatedHere{updated_at_id: updated_at.updated_at_id, updated_to: updated_at.updated_to as f64, updated_at_timestamp_ms: updated_at.updated_at_timestamp_ms},
        }
    }
}

#[derive(Debug, Clone)]
pub struct PlanParamsServer_Wealth {
    pub portfolio_balance: PlanParamsServer_PortfolioBalance,
    pub income_during_retirement: Vec<PlanParamsServer_AmountTimed>,
    pub future_savings: Vec<PlanParamsServer_AmountTimed>,
}

impl From<WirePlanParamsServerWealth> for PlanParamsServer_Wealth {
    fn from(wire: WirePlanParamsServerWealth) -> Self {
        Self {
            portfolio_balance: wire.portfolio_balance.unwrap().into(),
            income_during_retirement: wire.income_during_retirement.into_iter().map(|x| x.into()).collect(),
            future_savings: wire.future_savings.into_iter().map(|x| x.into()).collect(),
        }
    }
}

// ------- ADJUSTMENTS TO SPENDING -------
pub type PlanParamsServer_AdjustmentsToSpending_TPAWAndSPAW_Legacy = WirePlanParamsServerAdjustmentsToSpendingTpawAndSpawLegacy;

#[derive(Debug, Clone)]
pub struct PlanParamsServer_AdjustmentsToSpending_TPAWAndSPAW {
    pub spending_ceiling: Option<f64>,
    pub spending_floor: Option<f64>,
    pub legacy: PlanParamsServer_AdjustmentsToSpending_TPAWAndSPAW_Legacy,
}

impl From<WirePlanParamsServerAdjustmentsToSpendingTpawAndSpaw> for PlanParamsServer_AdjustmentsToSpending_TPAWAndSPAW {
    fn from(wire: WirePlanParamsServerAdjustmentsToSpendingTpawAndSpaw) -> Self {
        Self {
            spending_ceiling: wire.spending_ceiling.map(|x| x.value),
            spending_floor: wire.spending_floor.map(|x| x.value),
            legacy: wire.legacy,
        }
    }
}

#[derive(Debug, Clone)]
pub struct PlanParamsServer_AdjustmentsToSpending_ExtraSpending {
    pub essential: Vec<PlanParamsServer_AmountTimed>,
    pub discretionary: Vec<PlanParamsServer_AmountTimed>,
}
impl From<WirePlanParamsServerAdjustmentsToSpendingExtraSpending>
    for PlanParamsServer_AdjustmentsToSpending_ExtraSpending
{
    fn from(wire: WirePlanParamsServerAdjustmentsToSpendingExtraSpending) -> Self {
        Self {
            essential: wire.essential.into_iter().map(|x| x.into()).collect(),
            discretionary: wire.discretionary.into_iter().map(|x| x.into()).collect(),
        }
    }
}

#[derive(Debug, Clone)]
pub struct PlanParamsServer_AdjustmentsToSpending {
    pub extra_spending: PlanParamsServer_AdjustmentsToSpending_ExtraSpending,
    pub tpaw_and_spaw: PlanParamsServer_AdjustmentsToSpending_TPAWAndSPAW,
}

impl From<WirePlanParamsServerAdjustmentsToSpending> for PlanParamsServer_AdjustmentsToSpending {
    fn from(wire: WirePlanParamsServerAdjustmentsToSpending) -> Self {
        Self {
            extra_spending: wire.extra_spending.into(),
            tpaw_and_spaw: wire.tpaw_and_spaw.into(),
        }
    }
}

// ------- RISK -------
pub type PlanParamsServer_Risk_TPAW_RiskTolerance  = WirePlanParamsServerRiskTpawRiskTolerance;
pub type PlanParamsServer_Risk_TPAW =WirePlanParamsServerRiskTpaw;
pub type PlanParamsServer_Risk_SPAW = WirePlanParamsServerRiskSpaw;
pub type PlanParamsServer_Risk_SPAWAndSWR = WirePlanParamsServerRiskSpawAndSwr;
pub type PlanParamsServer_Risk_SWR_Withdrawal = wire_plan_params_server_risk_swr::Withdrawal;


#[derive(Debug, Clone)]
pub struct PlanParamsServer_Risk_SWR {
    pub withdrawal: PlanParamsServer_Risk_SWR_Withdrawal,
}
impl From<WirePlanParamsServerRiskSwr> for PlanParamsServer_Risk_SWR {
    fn from(wire: WirePlanParamsServerRiskSwr) -> Self {
        Self {
            withdrawal: wire.withdrawal.unwrap(),
        }
    }
}


#[derive(Debug, Clone)]
pub struct PlanParamsServer_Risk {
    pub tpaw: PlanParamsServer_Risk_TPAW,
    pub spaw: PlanParamsServer_Risk_SPAW,
    pub spaw_and_swr: PlanParamsServer_Risk_SPAWAndSWR,
    pub swr: PlanParamsServer_Risk_SWR,
}
impl From<WirePlanParamsServerRisk> for PlanParamsServer_Risk {
    fn from(wire: WirePlanParamsServerRisk) -> Self {
        Self {
            tpaw: wire.tpaw,
            spaw: wire.spaw,
            spaw_and_swr: wire.spaw_and_swr,
            swr: wire.swr.into(),
        }
    }
}


// ------- ADVANCED -------
pub type PlanParamsServer_ExpectedReturnsForPlanning_Custom_Stocks_Base = WirePlanParamsServerExpectedReturnsForPlanningCustomStocksBase;
pub type PlanParamsServer_ExpectedReturnsForPlanning_Custom_Bonds_Base =WirePlanParamsServerExpectedReturnsForPlanningCustomBondsBase;


#[derive(Debug, Clone)]
pub struct PlanParamsServer_ExpectedReturnsForPlanning_Custom_Stocks {
    pub base: PlanParamsServer_ExpectedReturnsForPlanning_Custom_Stocks_Base,
    pub delta: f64,
}
impl From<WirePlanParamsServerExpectedReturnsForPlanningCustomStocks>
    for PlanParamsServer_ExpectedReturnsForPlanning_Custom_Stocks
{
    fn from(wire: WirePlanParamsServerExpectedReturnsForPlanningCustomStocks) -> Self {
        Self {
            base: WirePlanParamsServerExpectedReturnsForPlanningCustomStocksBase::try_from(
                wire.base,
            )
            .unwrap()
            .into(),
            delta: wire.delta,
        }
    }
}

#[derive(Debug, Clone)]
pub struct PlanParamsServer_ExpectedReturnsForPlanning_Custom_Bonds {
    pub base: PlanParamsServer_ExpectedReturnsForPlanning_Custom_Bonds_Base,
    pub delta: f64,
}

impl From<WirePlanParamsServerExpectedReturnsForPlanningCustomBonds>
    for PlanParamsServer_ExpectedReturnsForPlanning_Custom_Bonds
{
    fn from(wire: WirePlanParamsServerExpectedReturnsForPlanningCustomBonds) -> Self {
        Self {
            base: WirePlanParamsServerExpectedReturnsForPlanningCustomBondsBase::try_from(
                wire.base,
            )
            .unwrap()
            .into(),
            delta: wire.delta,
        }
    }
}


#[derive(Debug, Clone)]
pub enum PlanParamsServer_ExpectedReturnsForPlanning_EmpiricalAnnualNonLog {
    RegressionPrediction_20YearTIPSYield,
    ConservativeEstimate_20YearTIPSYield,
    OneOverCAPE_20YearTIPSYield,
    Historical,
    FixedEquityPremium {
        equity_premium: f64,
    },
    Custom {
        stocks: PlanParamsServer_ExpectedReturnsForPlanning_Custom_Stocks,
        bonds: PlanParamsServer_ExpectedReturnsForPlanning_Custom_Bonds,
    },
    Fixed { stocks:f64, 
        bonds:f64,
    },
}
impl From<wire_plan_params_server_expected_returns_for_planning::EmpiricalAnnualNonLog> for PlanParamsServer_ExpectedReturnsForPlanning_EmpiricalAnnualNonLog {
    fn from(wire:wire_plan_params_server_expected_returns_for_planning::EmpiricalAnnualNonLog) -> Self {
        match wire {
            wire_plan_params_server_expected_returns_for_planning::EmpiricalAnnualNonLog::RegressionPrediction20YearTipsYield(_) => Self::RegressionPrediction_20YearTIPSYield,
            wire_plan_params_server_expected_returns_for_planning::EmpiricalAnnualNonLog::ConservativeEstimate20YearTipsYield(_) => Self::ConservativeEstimate_20YearTIPSYield,   
            wire_plan_params_server_expected_returns_for_planning::EmpiricalAnnualNonLog::OneOverCape20YearTipsYield(_) => Self::OneOverCAPE_20YearTIPSYield,
            wire_plan_params_server_expected_returns_for_planning::EmpiricalAnnualNonLog::Historical(_) => Self::Historical,
            wire_plan_params_server_expected_returns_for_planning::EmpiricalAnnualNonLog::FixedEquityPremium (equity_premium) => Self::FixedEquityPremium { equity_premium},
            wire_plan_params_server_expected_returns_for_planning::EmpiricalAnnualNonLog::Custom (custom) => Self::Custom { stocks: custom.stocks.into(), bonds: custom.bonds.into() },
            wire_plan_params_server_expected_returns_for_planning::EmpiricalAnnualNonLog::Fixed (fixed) => Self::Fixed { stocks: fixed.stocks, bonds: fixed.bonds }
        }
    }
}


#[derive(Debug, Clone)]
pub struct PlanParamsServer_ExpectedReturnsForPlanning {
    pub empirical_annual_non_log: PlanParamsServer_ExpectedReturnsForPlanning_EmpiricalAnnualNonLog,
}
impl From<WirePlanParamsServerExpectedReturnsForPlanning> for PlanParamsServer_ExpectedReturnsForPlanning {
    fn from(wire:WirePlanParamsServerExpectedReturnsForPlanning) -> Self {
        Self {
            empirical_annual_non_log: wire.empirical_annual_non_log.unwrap().into(),
        }
    }
}

pub type PlanParamsServer_ReturnStatsForPlanning_StandardDeviation= WirePlanParamsServerReturnStatsForPlanningStandardDeviation;


#[derive(Debug, Clone)]
pub struct PlanParamsServer_ReturnStatsForPlanning {
    pub expected_value: PlanParamsServer_ExpectedReturnsForPlanning,
    pub standard_deviation: PlanParamsServer_ReturnStatsForPlanning_StandardDeviation,
}

impl From<WirePlanParamsServerReturnStatsForPlanning> for PlanParamsServer_ReturnStatsForPlanning {
    fn from(wire: WirePlanParamsServerReturnStatsForPlanning) -> Self {
        Self {
            expected_value: wire.expected_value.into(),
            standard_deviation: wire.standard_deviation,
        }
    }
}

pub type PlanParamsServer_HistoricalReturnsAdjustment_StandardDeviation = WirePlanParamsServerHistoricalReturnsAdjustmentStandardDeviation;

#[derive(Debug, Clone)]
pub struct PlanParamsServer_HistoricalReturnsAdjustment {
    pub standard_deviation: WirePlanParamsServerHistoricalReturnsAdjustmentStandardDeviation,
    pub override_to_fixed_for_testing: wire_plan_params_server_historical_returns_adjustment::OverrideToFixedForTesting,
}

impl From<WirePlanParamsServerHistoricalReturnsAdjustment> for PlanParamsServer_HistoricalReturnsAdjustment {
    fn from(wire: WirePlanParamsServerHistoricalReturnsAdjustment) -> Self {
        Self {
            standard_deviation: wire.standard_deviation,
            override_to_fixed_for_testing: wire.override_to_fixed_for_testing.unwrap(),
        }
    }
}

pub type PlanParamsServer_Sampling_MonteCarlo = WirePlanParamsServerSamplingMonteCarlo;
pub type PlanParamsServer_Sampling = wire_plan_params_server_advanced::Sampling;
pub type PlanParamsServer_AnnualInflation = wire_plan_params_server_advanced::AnnualInflation;


#[derive(Debug, Clone)]
pub enum PlanParamsServer_Strategy {
    TPAW,
    SPAW,
    SWR,
}
impl From<WirePlanParamsServerStrategy> for PlanParamsServer_Strategy {
    fn from(wire: WirePlanParamsServerStrategy) -> Self {
        match wire {
            WirePlanParamsServerStrategy::StrategyTpaw => Self::TPAW,
            WirePlanParamsServerStrategy::StrategySpaw => Self::SPAW,
            WirePlanParamsServerStrategy::StrategySwr => Self::SWR,
        }
    }
}


#[derive(Debug, Clone)]
pub struct PlanParamsServer_Advanced {
    pub return_stats_for_planning: PlanParamsServer_ReturnStatsForPlanning,
    pub historical_returns_adjustment: PlanParamsServer_HistoricalReturnsAdjustment,
    pub sampling: PlanParamsServer_Sampling,
    pub strategy: PlanParamsServer_Strategy,
    pub annual_inflation: PlanParamsServer_AnnualInflation,
}

impl From<WirePlanParamsServerAdvanced> for PlanParamsServer_Advanced {
    fn from(wire: WirePlanParamsServerAdvanced) -> Self {
        Self {
            return_stats_for_planning: wire.return_stats_for_planning.into(),
            historical_returns_adjustment: wire.historical_returns_adjustment.into(),
            sampling: wire.sampling.unwrap(),
            annual_inflation: wire.annual_inflation.unwrap(),
            strategy: WirePlanParamsServerStrategy::try_from(wire.strategy)
                .unwrap()
                .into(),
        }
    }
}

// ------- PLAN PARAMS SERVER -------
#[derive(Debug, Clone)]
pub struct PlanParamsServer {
    pub evaluation_timestamp_ms: i64,
    pub constants: PlanParamsServer_Constants,
    pub ages: PlanParamsServer_Ages,
    pub wealth: PlanParamsServer_Wealth,
    pub adjustments_to_spending: PlanParamsServer_AdjustmentsToSpending,
    pub risk: PlanParamsServer_Risk,
    pub advanced: PlanParamsServer_Advanced,
}

impl From<WirePlanParamsServer> for PlanParamsServer {
    fn from(wire: WirePlanParamsServer) -> Self {
        Self {
            evaluation_timestamp_ms: wire.evaluation_timestamp_ms,
            constants: wire.constants,
            ages: wire.ages,
            wealth: wire.wealth.into(),
            adjustments_to_spending: wire.adjustments_to_spending.into(),
            risk: wire.risk.into(),
            advanced: wire.advanced.into(),
        }
    }
}



pub fn get_test_plan_params_server(num_runs: u32, evaluation_timestamp_ms: i64) -> PlanParamsServer {
    let num_months = 120 * 12;
    PlanParamsServer {
        evaluation_timestamp_ms,
        constants: PlanParamsServer_Constants {
            risk_tolerance_num_integer_values_starting_from_0: 25,
            risk_tolerance_start_rra: 16.0,
            risk_tolerance_end_rra: 0.5,
        },
        ages: PlanParamsServer_Ages {
            simulation_months: PlanParamsServer_Ages_SimulationMonths {
                num_months,
                // withdrawal_start_month: 60 * 12,
                withdrawal_start_month: 0,
            },
            longer_lived_person: {
                let current_age = 30 * 12;
                PlanParamsServer_Ages_Person {
                    current_age,
                    max_age: current_age + num_months,
                }
            },
        },
        wealth: PlanParamsServer_Wealth { 
            portfolio_balance: PlanParamsServer_PortfolioBalance::UpdatedHere(1_000_000.0),
            income_during_retirement: vec![],
            future_savings: vec![],
        },
        adjustments_to_spending: PlanParamsServer_AdjustmentsToSpending {
            tpaw_and_spaw: PlanParamsServer_AdjustmentsToSpending_TPAWAndSPAW {
                spending_ceiling: None,
                spending_floor: None,
                legacy: PlanParamsServer_AdjustmentsToSpending_TPAWAndSPAW_Legacy {
                    total: 0.0,
                    external: vec![],
                },
            },
            extra_spending: PlanParamsServer_AdjustmentsToSpending_ExtraSpending {
                essential: vec![],
                discretionary: vec![],
            },
        },
        risk: PlanParamsServer_Risk {
            tpaw: PlanParamsServer_Risk_TPAW {
                risk_tolerance: PlanParamsServer_Risk_TPAW_RiskTolerance {
                    at20: 12.0,
                    delta_at_max_age: 0.0,
                    for_legacy_as_delta_from_at20: 0.0,
                },
                time_preference: 0.0,
                additional_annual_spending_tilt: 0.0,
            },
            spaw: PlanParamsServer_Risk_SPAW {
                annual_spending_tilt: 0.0,
            },
            spaw_and_swr: PlanParamsServer_Risk_SPAWAndSWR {
                stock_allocation: PlanParamsServer_GlidePath {
                    now: 0.5,
                    intermediate: vec![],
                    end: 0.5,
                },
            },
            swr: PlanParamsServer_Risk_SWR {
                withdrawal: PlanParamsServer_Risk_SWR_Withdrawal::PercentPerYear(0.04),
            },
        },
        advanced: PlanParamsServer_Advanced {
            return_stats_for_planning: PlanParamsServer_ReturnStatsForPlanning{
                expected_value:PlanParamsServer_ExpectedReturnsForPlanning{
                    empirical_annual_non_log: PlanParamsServer_ExpectedReturnsForPlanning_EmpiricalAnnualNonLog::RegressionPrediction_20YearTIPSYield
                },
                standard_deviation: PlanParamsServer_ReturnStatsForPlanning_StandardDeviation{
                    stocks: ScaleLogF64{
                        scale:LogF64 {
                            log: 1.0
                        },
                    },
                },
            },
            sampling: PlanParamsServer_Sampling::MonteCarlo(PlanParamsServer_Sampling_MonteCarlo{
                seed:1234,
                num_runs,
                block_size: 5 * 12, 
                stagger_run_starts: true}),
            annual_inflation: PlanParamsServer_AnnualInflation::Suggested(NoMessage {}),
            historical_returns_adjustment: PlanParamsServer_HistoricalReturnsAdjustment {
                standard_deviation: PlanParamsServer_HistoricalReturnsAdjustment_StandardDeviation{
                    bonds: ScaleLogF64{
                        scale:LogF64 {
                            log: 1.0
                        },
                    },
                },
                override_to_fixed_for_testing: wire_plan_params_server_historical_returns_adjustment::OverrideToFixedForTesting::None(NoMessage {}),
            },
            strategy: PlanParamsServer_Strategy::TPAW,
        },
    }
}
