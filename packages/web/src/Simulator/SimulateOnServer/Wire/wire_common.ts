// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.12.4
// source: wire_common.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "wire";

export interface WireStockAllocation {
  stocksX100: number;
}

/** Needed because optional double set to 0 was read as None. */
export interface WireBoxedDouble {
  value: number;
}

export interface WireYearAndMonth {
  year: number;
  month: number;
}

export interface WireMonthRange {
  start: WireYearAndMonth | undefined;
  end: WireYearAndMonth | undefined;
}

export interface WireStats {
  mean: number;
  variance: number;
  standardDeviation: number;
  n: number;
}

export interface WireLogAndNonLogStats {
  log: WireStats | undefined;
  nonLog: WireStats | undefined;
}

export interface WireIdAndDouble {
  id: string;
  value: number;
}

export interface NoMessage {
}

function createBaseWireStockAllocation(): WireStockAllocation {
  return { stocksX100: 0 };
}

export const WireStockAllocation = {
  encode(message: WireStockAllocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stocksX100 !== 0) {
      writer.uint32(8).int64(message.stocksX100);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WireStockAllocation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireStockAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.stocksX100 = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireStockAllocation {
    return { stocksX100: isSet(object.stocksX100) ? globalThis.Number(object.stocksX100) : 0 };
  },

  toJSON(message: WireStockAllocation): unknown {
    const obj: any = {};
    if (message.stocksX100 !== 0) {
      obj.stocksX100 = Math.round(message.stocksX100);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireStockAllocation>, I>>(base?: I): WireStockAllocation {
    return WireStockAllocation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireStockAllocation>, I>>(object: I): WireStockAllocation {
    const message = createBaseWireStockAllocation();
    message.stocksX100 = object.stocksX100 ?? 0;
    return message;
  },
};

function createBaseWireBoxedDouble(): WireBoxedDouble {
  return { value: 0 };
}

export const WireBoxedDouble = {
  encode(message: WireBoxedDouble, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WireBoxedDouble {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireBoxedDouble();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireBoxedDouble {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: WireBoxedDouble): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireBoxedDouble>, I>>(base?: I): WireBoxedDouble {
    return WireBoxedDouble.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireBoxedDouble>, I>>(object: I): WireBoxedDouble {
    const message = createBaseWireBoxedDouble();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseWireYearAndMonth(): WireYearAndMonth {
  return { year: 0, month: 0 };
}

export const WireYearAndMonth = {
  encode(message: WireYearAndMonth, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.year !== 0) {
      writer.uint32(8).int64(message.year);
    }
    if (message.month !== 0) {
      writer.uint32(16).int64(message.month);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WireYearAndMonth {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireYearAndMonth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.year = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.month = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireYearAndMonth {
    return {
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      month: isSet(object.month) ? globalThis.Number(object.month) : 0,
    };
  },

  toJSON(message: WireYearAndMonth): unknown {
    const obj: any = {};
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.month !== 0) {
      obj.month = Math.round(message.month);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireYearAndMonth>, I>>(base?: I): WireYearAndMonth {
    return WireYearAndMonth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireYearAndMonth>, I>>(object: I): WireYearAndMonth {
    const message = createBaseWireYearAndMonth();
    message.year = object.year ?? 0;
    message.month = object.month ?? 0;
    return message;
  },
};

function createBaseWireMonthRange(): WireMonthRange {
  return { start: undefined, end: undefined };
}

export const WireMonthRange = {
  encode(message: WireMonthRange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.start !== undefined) {
      WireYearAndMonth.encode(message.start, writer.uint32(10).fork()).ldelim();
    }
    if (message.end !== undefined) {
      WireYearAndMonth.encode(message.end, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WireMonthRange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireMonthRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.start = WireYearAndMonth.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.end = WireYearAndMonth.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireMonthRange {
    return {
      start: isSet(object.start) ? WireYearAndMonth.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? WireYearAndMonth.fromJSON(object.end) : undefined,
    };
  },

  toJSON(message: WireMonthRange): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = WireYearAndMonth.toJSON(message.start);
    }
    if (message.end !== undefined) {
      obj.end = WireYearAndMonth.toJSON(message.end);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireMonthRange>, I>>(base?: I): WireMonthRange {
    return WireMonthRange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireMonthRange>, I>>(object: I): WireMonthRange {
    const message = createBaseWireMonthRange();
    message.start = (object.start !== undefined && object.start !== null)
      ? WireYearAndMonth.fromPartial(object.start)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null)
      ? WireYearAndMonth.fromPartial(object.end)
      : undefined;
    return message;
  },
};

function createBaseWireStats(): WireStats {
  return { mean: 0, variance: 0, standardDeviation: 0, n: 0 };
}

export const WireStats = {
  encode(message: WireStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mean !== 0) {
      writer.uint32(9).double(message.mean);
    }
    if (message.variance !== 0) {
      writer.uint32(17).double(message.variance);
    }
    if (message.standardDeviation !== 0) {
      writer.uint32(25).double(message.standardDeviation);
    }
    if (message.n !== 0) {
      writer.uint32(32).int64(message.n);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WireStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.mean = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.variance = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.standardDeviation = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.n = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireStats {
    return {
      mean: isSet(object.mean) ? globalThis.Number(object.mean) : 0,
      variance: isSet(object.variance) ? globalThis.Number(object.variance) : 0,
      standardDeviation: isSet(object.standardDeviation) ? globalThis.Number(object.standardDeviation) : 0,
      n: isSet(object.n) ? globalThis.Number(object.n) : 0,
    };
  },

  toJSON(message: WireStats): unknown {
    const obj: any = {};
    if (message.mean !== 0) {
      obj.mean = message.mean;
    }
    if (message.variance !== 0) {
      obj.variance = message.variance;
    }
    if (message.standardDeviation !== 0) {
      obj.standardDeviation = message.standardDeviation;
    }
    if (message.n !== 0) {
      obj.n = Math.round(message.n);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireStats>, I>>(base?: I): WireStats {
    return WireStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireStats>, I>>(object: I): WireStats {
    const message = createBaseWireStats();
    message.mean = object.mean ?? 0;
    message.variance = object.variance ?? 0;
    message.standardDeviation = object.standardDeviation ?? 0;
    message.n = object.n ?? 0;
    return message;
  },
};

function createBaseWireLogAndNonLogStats(): WireLogAndNonLogStats {
  return { log: undefined, nonLog: undefined };
}

export const WireLogAndNonLogStats = {
  encode(message: WireLogAndNonLogStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.log !== undefined) {
      WireStats.encode(message.log, writer.uint32(10).fork()).ldelim();
    }
    if (message.nonLog !== undefined) {
      WireStats.encode(message.nonLog, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WireLogAndNonLogStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireLogAndNonLogStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.log = WireStats.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nonLog = WireStats.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireLogAndNonLogStats {
    return {
      log: isSet(object.log) ? WireStats.fromJSON(object.log) : undefined,
      nonLog: isSet(object.nonLog) ? WireStats.fromJSON(object.nonLog) : undefined,
    };
  },

  toJSON(message: WireLogAndNonLogStats): unknown {
    const obj: any = {};
    if (message.log !== undefined) {
      obj.log = WireStats.toJSON(message.log);
    }
    if (message.nonLog !== undefined) {
      obj.nonLog = WireStats.toJSON(message.nonLog);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireLogAndNonLogStats>, I>>(base?: I): WireLogAndNonLogStats {
    return WireLogAndNonLogStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireLogAndNonLogStats>, I>>(object: I): WireLogAndNonLogStats {
    const message = createBaseWireLogAndNonLogStats();
    message.log = (object.log !== undefined && object.log !== null) ? WireStats.fromPartial(object.log) : undefined;
    message.nonLog = (object.nonLog !== undefined && object.nonLog !== null)
      ? WireStats.fromPartial(object.nonLog)
      : undefined;
    return message;
  },
};

function createBaseWireIdAndDouble(): WireIdAndDouble {
  return { id: "", value: 0 };
}

export const WireIdAndDouble = {
  encode(message: WireIdAndDouble, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WireIdAndDouble {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireIdAndDouble();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireIdAndDouble {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: WireIdAndDouble): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireIdAndDouble>, I>>(base?: I): WireIdAndDouble {
    return WireIdAndDouble.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireIdAndDouble>, I>>(object: I): WireIdAndDouble {
    const message = createBaseWireIdAndDouble();
    message.id = object.id ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseNoMessage(): NoMessage {
  return {};
}

export const NoMessage = {
  encode(_: NoMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NoMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NoMessage {
    return {};
  },

  toJSON(_: NoMessage): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NoMessage>, I>>(base?: I): NoMessage {
    return NoMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NoMessage>, I>>(_: I): NoMessage {
    const message = createBaseNoMessage();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
