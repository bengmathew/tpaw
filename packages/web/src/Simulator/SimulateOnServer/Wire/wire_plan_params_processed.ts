// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.12.4
// source: wire_plan_params_processed.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { WireLogAndNonLogStats, WireMonthRange, WireStats } from "./wire_common";
import { WireMarketDataForPresetsProcessed } from "./wire_market_data_for_presets_processed";

export const protobufPackage = "wire";

/** Using proto2 because the absence of required fields in proto3 is painful. */

export interface WireAmountTimedProcessedSingle {
  id: string;
  valuesX100: number[];
}

export interface WireAmountTimedProcessedGroup {
  totalX100: number[];
  byId: WireAmountTimedProcessedSingle[];
}

export interface WireAmountTimedProcessed {
  wealthIncomeDuringRetirement: WireAmountTimedProcessedGroup | undefined;
  wealthFutureSavings: WireAmountTimedProcessedGroup | undefined;
  extraExpensesEssential: WireAmountTimedProcessedGroup | undefined;
  extraExpensesDiscretionary: WireAmountTimedProcessedGroup | undefined;
}

/** ---- HISTORICAL RETURNS ---- */
export interface WireHistoricalMonthlyLogReturnsAdjustedStats {
  log: WireStats | undefined;
  annualized: WireLogAndNonLogStats | undefined;
}

export interface WireHistoricalMonthlyLogReturnsAdjustedInfoArgs {
  empiricalAnnualNonLogExpectedReturn: number;
  empiricalAnnualLogVariance: number;
}

export interface WireHistoricalMonthlyLogReturnsAdjustedInfo {
  stats: WireHistoricalMonthlyLogReturnsAdjustedStats | undefined;
  args: WireHistoricalMonthlyLogReturnsAdjustedInfoArgs | undefined;
  srcAnnualizedStats: WireLogAndNonLogStats | undefined;
}

export interface WireHistoricalReturnsProcessed {
  monthRange: WireMonthRange | undefined;
  stocks: WireHistoricalMonthlyLogReturnsAdjustedInfo | undefined;
  bonds: WireHistoricalMonthlyLogReturnsAdjustedInfo | undefined;
}

/** ---- RETURN STATS FOR PLANNING ---- */
export interface WireReturnsStatsForPlanningProcessedPart {
  empiricalAnnualNonLogExpectedReturn: number;
  empiricalAnnualLogVariance: number;
}

export interface WireReturnsStatsForPlanningProcessed {
  stocks: WireReturnsStatsForPlanningProcessedPart | undefined;
  bonds: WireReturnsStatsForPlanningProcessedPart | undefined;
}

export interface WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy {
  external: number;
  target: number;
}

export interface WireAdjustmentsToSpendingProcessedTpawAndSpaw {
  legacy: WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy | undefined;
}

export interface WireAdjustmentsToSpendingProcessed {
  tpawAndSpaw: WireAdjustmentsToSpendingProcessedTpawAndSpaw | undefined;
}

/**
 * ---- RISK ----
 * Note: Verified that infinity works over the wire.
 */
export interface WireRiskProcessedTpaw {
  riskToleranceByMfn: number[];
  rraUnclampedAt20IncludingPosInfinity: number;
  rraUnclampedIncludingPosInfinityByMfn: number[];
  legacyRraIncludingPosInfinity: number;
}

export interface WireRiskProcessed {
  tpaw: WireRiskProcessedTpaw | undefined;
}

/** ---- PLAN PARAMS PROCESSED ---- */
export interface WirePlanParamsProcessed {
  marketDataForPresets: WireMarketDataForPresetsProcessed | undefined;
  returnsStatsForPlanning: WireReturnsStatsForPlanningProcessed | undefined;
  historicalReturns: WireHistoricalReturnsProcessed | undefined;
  amountTimed: WireAmountTimedProcessed | undefined;
  adjustmentsToSpending: WireAdjustmentsToSpendingProcessed | undefined;
  risk: WireRiskProcessed | undefined;
  annualInflation: number;
}

function createBaseWireAmountTimedProcessedSingle(): WireAmountTimedProcessedSingle {
  return { id: "", valuesX100: [] };
}

export const WireAmountTimedProcessedSingle: MessageFns<WireAmountTimedProcessedSingle> = {
  encode(message: WireAmountTimedProcessedSingle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    writer.uint32(18).fork();
    for (const v of message.valuesX100) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireAmountTimedProcessedSingle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireAmountTimedProcessedSingle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.valuesX100.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.valuesX100.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireAmountTimedProcessedSingle {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      valuesX100: globalThis.Array.isArray(object?.valuesX100)
        ? object.valuesX100.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: WireAmountTimedProcessedSingle): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.valuesX100?.length) {
      obj.valuesX100 = message.valuesX100.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireAmountTimedProcessedSingle>, I>>(base?: I): WireAmountTimedProcessedSingle {
    return WireAmountTimedProcessedSingle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireAmountTimedProcessedSingle>, I>>(
    object: I,
  ): WireAmountTimedProcessedSingle {
    const message = createBaseWireAmountTimedProcessedSingle();
    message.id = object.id ?? "";
    message.valuesX100 = object.valuesX100?.map((e) => e) || [];
    return message;
  },
};

function createBaseWireAmountTimedProcessedGroup(): WireAmountTimedProcessedGroup {
  return { totalX100: [], byId: [] };
}

export const WireAmountTimedProcessedGroup: MessageFns<WireAmountTimedProcessedGroup> = {
  encode(message: WireAmountTimedProcessedGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.totalX100) {
      writer.int64(v);
    }
    writer.join();
    for (const v of message.byId) {
      WireAmountTimedProcessedSingle.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireAmountTimedProcessedGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireAmountTimedProcessedGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.totalX100.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.totalX100.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.byId.push(WireAmountTimedProcessedSingle.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireAmountTimedProcessedGroup {
    return {
      totalX100: globalThis.Array.isArray(object?.totalX100)
        ? object.totalX100.map((e: any) => globalThis.Number(e))
        : [],
      byId: globalThis.Array.isArray(object?.byId)
        ? object.byId.map((e: any) => WireAmountTimedProcessedSingle.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WireAmountTimedProcessedGroup): unknown {
    const obj: any = {};
    if (message.totalX100?.length) {
      obj.totalX100 = message.totalX100.map((e) => Math.round(e));
    }
    if (message.byId?.length) {
      obj.byId = message.byId.map((e) => WireAmountTimedProcessedSingle.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireAmountTimedProcessedGroup>, I>>(base?: I): WireAmountTimedProcessedGroup {
    return WireAmountTimedProcessedGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireAmountTimedProcessedGroup>, I>>(
    object: I,
  ): WireAmountTimedProcessedGroup {
    const message = createBaseWireAmountTimedProcessedGroup();
    message.totalX100 = object.totalX100?.map((e) => e) || [];
    message.byId = object.byId?.map((e) => WireAmountTimedProcessedSingle.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWireAmountTimedProcessed(): WireAmountTimedProcessed {
  return {
    wealthIncomeDuringRetirement: undefined,
    wealthFutureSavings: undefined,
    extraExpensesEssential: undefined,
    extraExpensesDiscretionary: undefined,
  };
}

export const WireAmountTimedProcessed: MessageFns<WireAmountTimedProcessed> = {
  encode(message: WireAmountTimedProcessed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.wealthIncomeDuringRetirement !== undefined) {
      WireAmountTimedProcessedGroup.encode(message.wealthIncomeDuringRetirement, writer.uint32(10).fork()).join();
    }
    if (message.wealthFutureSavings !== undefined) {
      WireAmountTimedProcessedGroup.encode(message.wealthFutureSavings, writer.uint32(18).fork()).join();
    }
    if (message.extraExpensesEssential !== undefined) {
      WireAmountTimedProcessedGroup.encode(message.extraExpensesEssential, writer.uint32(26).fork()).join();
    }
    if (message.extraExpensesDiscretionary !== undefined) {
      WireAmountTimedProcessedGroup.encode(message.extraExpensesDiscretionary, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireAmountTimedProcessed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireAmountTimedProcessed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.wealthIncomeDuringRetirement = WireAmountTimedProcessedGroup.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.wealthFutureSavings = WireAmountTimedProcessedGroup.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.extraExpensesEssential = WireAmountTimedProcessedGroup.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.extraExpensesDiscretionary = WireAmountTimedProcessedGroup.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireAmountTimedProcessed {
    return {
      wealthIncomeDuringRetirement: isSet(object.wealthIncomeDuringRetirement)
        ? WireAmountTimedProcessedGroup.fromJSON(object.wealthIncomeDuringRetirement)
        : undefined,
      wealthFutureSavings: isSet(object.wealthFutureSavings)
        ? WireAmountTimedProcessedGroup.fromJSON(object.wealthFutureSavings)
        : undefined,
      extraExpensesEssential: isSet(object.extraExpensesEssential)
        ? WireAmountTimedProcessedGroup.fromJSON(object.extraExpensesEssential)
        : undefined,
      extraExpensesDiscretionary: isSet(object.extraExpensesDiscretionary)
        ? WireAmountTimedProcessedGroup.fromJSON(object.extraExpensesDiscretionary)
        : undefined,
    };
  },

  toJSON(message: WireAmountTimedProcessed): unknown {
    const obj: any = {};
    if (message.wealthIncomeDuringRetirement !== undefined) {
      obj.wealthIncomeDuringRetirement = WireAmountTimedProcessedGroup.toJSON(message.wealthIncomeDuringRetirement);
    }
    if (message.wealthFutureSavings !== undefined) {
      obj.wealthFutureSavings = WireAmountTimedProcessedGroup.toJSON(message.wealthFutureSavings);
    }
    if (message.extraExpensesEssential !== undefined) {
      obj.extraExpensesEssential = WireAmountTimedProcessedGroup.toJSON(message.extraExpensesEssential);
    }
    if (message.extraExpensesDiscretionary !== undefined) {
      obj.extraExpensesDiscretionary = WireAmountTimedProcessedGroup.toJSON(message.extraExpensesDiscretionary);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireAmountTimedProcessed>, I>>(base?: I): WireAmountTimedProcessed {
    return WireAmountTimedProcessed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireAmountTimedProcessed>, I>>(object: I): WireAmountTimedProcessed {
    const message = createBaseWireAmountTimedProcessed();
    message.wealthIncomeDuringRetirement =
      (object.wealthIncomeDuringRetirement !== undefined && object.wealthIncomeDuringRetirement !== null)
        ? WireAmountTimedProcessedGroup.fromPartial(object.wealthIncomeDuringRetirement)
        : undefined;
    message.wealthFutureSavings = (object.wealthFutureSavings !== undefined && object.wealthFutureSavings !== null)
      ? WireAmountTimedProcessedGroup.fromPartial(object.wealthFutureSavings)
      : undefined;
    message.extraExpensesEssential =
      (object.extraExpensesEssential !== undefined && object.extraExpensesEssential !== null)
        ? WireAmountTimedProcessedGroup.fromPartial(object.extraExpensesEssential)
        : undefined;
    message.extraExpensesDiscretionary =
      (object.extraExpensesDiscretionary !== undefined && object.extraExpensesDiscretionary !== null)
        ? WireAmountTimedProcessedGroup.fromPartial(object.extraExpensesDiscretionary)
        : undefined;
    return message;
  },
};

function createBaseWireHistoricalMonthlyLogReturnsAdjustedStats(): WireHistoricalMonthlyLogReturnsAdjustedStats {
  return { log: undefined, annualized: undefined };
}

export const WireHistoricalMonthlyLogReturnsAdjustedStats: MessageFns<WireHistoricalMonthlyLogReturnsAdjustedStats> = {
  encode(
    message: WireHistoricalMonthlyLogReturnsAdjustedStats,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.log !== undefined) {
      WireStats.encode(message.log, writer.uint32(10).fork()).join();
    }
    if (message.annualized !== undefined) {
      WireLogAndNonLogStats.encode(message.annualized, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireHistoricalMonthlyLogReturnsAdjustedStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireHistoricalMonthlyLogReturnsAdjustedStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.log = WireStats.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.annualized = WireLogAndNonLogStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireHistoricalMonthlyLogReturnsAdjustedStats {
    return {
      log: isSet(object.log) ? WireStats.fromJSON(object.log) : undefined,
      annualized: isSet(object.annualized) ? WireLogAndNonLogStats.fromJSON(object.annualized) : undefined,
    };
  },

  toJSON(message: WireHistoricalMonthlyLogReturnsAdjustedStats): unknown {
    const obj: any = {};
    if (message.log !== undefined) {
      obj.log = WireStats.toJSON(message.log);
    }
    if (message.annualized !== undefined) {
      obj.annualized = WireLogAndNonLogStats.toJSON(message.annualized);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireHistoricalMonthlyLogReturnsAdjustedStats>, I>>(
    base?: I,
  ): WireHistoricalMonthlyLogReturnsAdjustedStats {
    return WireHistoricalMonthlyLogReturnsAdjustedStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireHistoricalMonthlyLogReturnsAdjustedStats>, I>>(
    object: I,
  ): WireHistoricalMonthlyLogReturnsAdjustedStats {
    const message = createBaseWireHistoricalMonthlyLogReturnsAdjustedStats();
    message.log = (object.log !== undefined && object.log !== null) ? WireStats.fromPartial(object.log) : undefined;
    message.annualized = (object.annualized !== undefined && object.annualized !== null)
      ? WireLogAndNonLogStats.fromPartial(object.annualized)
      : undefined;
    return message;
  },
};

function createBaseWireHistoricalMonthlyLogReturnsAdjustedInfoArgs(): WireHistoricalMonthlyLogReturnsAdjustedInfoArgs {
  return { empiricalAnnualNonLogExpectedReturn: 0, empiricalAnnualLogVariance: 0 };
}

export const WireHistoricalMonthlyLogReturnsAdjustedInfoArgs: MessageFns<
  WireHistoricalMonthlyLogReturnsAdjustedInfoArgs
> = {
  encode(
    message: WireHistoricalMonthlyLogReturnsAdjustedInfoArgs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.empiricalAnnualNonLogExpectedReturn !== 0) {
      writer.uint32(9).double(message.empiricalAnnualNonLogExpectedReturn);
    }
    if (message.empiricalAnnualLogVariance !== 0) {
      writer.uint32(17).double(message.empiricalAnnualLogVariance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireHistoricalMonthlyLogReturnsAdjustedInfoArgs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireHistoricalMonthlyLogReturnsAdjustedInfoArgs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.empiricalAnnualNonLogExpectedReturn = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.empiricalAnnualLogVariance = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireHistoricalMonthlyLogReturnsAdjustedInfoArgs {
    return {
      empiricalAnnualNonLogExpectedReturn: isSet(object.empiricalAnnualNonLogExpectedReturn)
        ? globalThis.Number(object.empiricalAnnualNonLogExpectedReturn)
        : 0,
      empiricalAnnualLogVariance: isSet(object.empiricalAnnualLogVariance)
        ? globalThis.Number(object.empiricalAnnualLogVariance)
        : 0,
    };
  },

  toJSON(message: WireHistoricalMonthlyLogReturnsAdjustedInfoArgs): unknown {
    const obj: any = {};
    if (message.empiricalAnnualNonLogExpectedReturn !== 0) {
      obj.empiricalAnnualNonLogExpectedReturn = message.empiricalAnnualNonLogExpectedReturn;
    }
    if (message.empiricalAnnualLogVariance !== 0) {
      obj.empiricalAnnualLogVariance = message.empiricalAnnualLogVariance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireHistoricalMonthlyLogReturnsAdjustedInfoArgs>, I>>(
    base?: I,
  ): WireHistoricalMonthlyLogReturnsAdjustedInfoArgs {
    return WireHistoricalMonthlyLogReturnsAdjustedInfoArgs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireHistoricalMonthlyLogReturnsAdjustedInfoArgs>, I>>(
    object: I,
  ): WireHistoricalMonthlyLogReturnsAdjustedInfoArgs {
    const message = createBaseWireHistoricalMonthlyLogReturnsAdjustedInfoArgs();
    message.empiricalAnnualNonLogExpectedReturn = object.empiricalAnnualNonLogExpectedReturn ?? 0;
    message.empiricalAnnualLogVariance = object.empiricalAnnualLogVariance ?? 0;
    return message;
  },
};

function createBaseWireHistoricalMonthlyLogReturnsAdjustedInfo(): WireHistoricalMonthlyLogReturnsAdjustedInfo {
  return { stats: undefined, args: undefined, srcAnnualizedStats: undefined };
}

export const WireHistoricalMonthlyLogReturnsAdjustedInfo: MessageFns<WireHistoricalMonthlyLogReturnsAdjustedInfo> = {
  encode(
    message: WireHistoricalMonthlyLogReturnsAdjustedInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.stats !== undefined) {
      WireHistoricalMonthlyLogReturnsAdjustedStats.encode(message.stats, writer.uint32(10).fork()).join();
    }
    if (message.args !== undefined) {
      WireHistoricalMonthlyLogReturnsAdjustedInfoArgs.encode(message.args, writer.uint32(18).fork()).join();
    }
    if (message.srcAnnualizedStats !== undefined) {
      WireLogAndNonLogStats.encode(message.srcAnnualizedStats, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireHistoricalMonthlyLogReturnsAdjustedInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireHistoricalMonthlyLogReturnsAdjustedInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stats = WireHistoricalMonthlyLogReturnsAdjustedStats.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.args = WireHistoricalMonthlyLogReturnsAdjustedInfoArgs.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.srcAnnualizedStats = WireLogAndNonLogStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireHistoricalMonthlyLogReturnsAdjustedInfo {
    return {
      stats: isSet(object.stats) ? WireHistoricalMonthlyLogReturnsAdjustedStats.fromJSON(object.stats) : undefined,
      args: isSet(object.args) ? WireHistoricalMonthlyLogReturnsAdjustedInfoArgs.fromJSON(object.args) : undefined,
      srcAnnualizedStats: isSet(object.srcAnnualizedStats)
        ? WireLogAndNonLogStats.fromJSON(object.srcAnnualizedStats)
        : undefined,
    };
  },

  toJSON(message: WireHistoricalMonthlyLogReturnsAdjustedInfo): unknown {
    const obj: any = {};
    if (message.stats !== undefined) {
      obj.stats = WireHistoricalMonthlyLogReturnsAdjustedStats.toJSON(message.stats);
    }
    if (message.args !== undefined) {
      obj.args = WireHistoricalMonthlyLogReturnsAdjustedInfoArgs.toJSON(message.args);
    }
    if (message.srcAnnualizedStats !== undefined) {
      obj.srcAnnualizedStats = WireLogAndNonLogStats.toJSON(message.srcAnnualizedStats);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireHistoricalMonthlyLogReturnsAdjustedInfo>, I>>(
    base?: I,
  ): WireHistoricalMonthlyLogReturnsAdjustedInfo {
    return WireHistoricalMonthlyLogReturnsAdjustedInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireHistoricalMonthlyLogReturnsAdjustedInfo>, I>>(
    object: I,
  ): WireHistoricalMonthlyLogReturnsAdjustedInfo {
    const message = createBaseWireHistoricalMonthlyLogReturnsAdjustedInfo();
    message.stats = (object.stats !== undefined && object.stats !== null)
      ? WireHistoricalMonthlyLogReturnsAdjustedStats.fromPartial(object.stats)
      : undefined;
    message.args = (object.args !== undefined && object.args !== null)
      ? WireHistoricalMonthlyLogReturnsAdjustedInfoArgs.fromPartial(object.args)
      : undefined;
    message.srcAnnualizedStats = (object.srcAnnualizedStats !== undefined && object.srcAnnualizedStats !== null)
      ? WireLogAndNonLogStats.fromPartial(object.srcAnnualizedStats)
      : undefined;
    return message;
  },
};

function createBaseWireHistoricalReturnsProcessed(): WireHistoricalReturnsProcessed {
  return { monthRange: undefined, stocks: undefined, bonds: undefined };
}

export const WireHistoricalReturnsProcessed: MessageFns<WireHistoricalReturnsProcessed> = {
  encode(message: WireHistoricalReturnsProcessed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.monthRange !== undefined) {
      WireMonthRange.encode(message.monthRange, writer.uint32(10).fork()).join();
    }
    if (message.stocks !== undefined) {
      WireHistoricalMonthlyLogReturnsAdjustedInfo.encode(message.stocks, writer.uint32(18).fork()).join();
    }
    if (message.bonds !== undefined) {
      WireHistoricalMonthlyLogReturnsAdjustedInfo.encode(message.bonds, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireHistoricalReturnsProcessed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireHistoricalReturnsProcessed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.monthRange = WireMonthRange.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stocks = WireHistoricalMonthlyLogReturnsAdjustedInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bonds = WireHistoricalMonthlyLogReturnsAdjustedInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireHistoricalReturnsProcessed {
    return {
      monthRange: isSet(object.monthRange) ? WireMonthRange.fromJSON(object.monthRange) : undefined,
      stocks: isSet(object.stocks) ? WireHistoricalMonthlyLogReturnsAdjustedInfo.fromJSON(object.stocks) : undefined,
      bonds: isSet(object.bonds) ? WireHistoricalMonthlyLogReturnsAdjustedInfo.fromJSON(object.bonds) : undefined,
    };
  },

  toJSON(message: WireHistoricalReturnsProcessed): unknown {
    const obj: any = {};
    if (message.monthRange !== undefined) {
      obj.monthRange = WireMonthRange.toJSON(message.monthRange);
    }
    if (message.stocks !== undefined) {
      obj.stocks = WireHistoricalMonthlyLogReturnsAdjustedInfo.toJSON(message.stocks);
    }
    if (message.bonds !== undefined) {
      obj.bonds = WireHistoricalMonthlyLogReturnsAdjustedInfo.toJSON(message.bonds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireHistoricalReturnsProcessed>, I>>(base?: I): WireHistoricalReturnsProcessed {
    return WireHistoricalReturnsProcessed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireHistoricalReturnsProcessed>, I>>(
    object: I,
  ): WireHistoricalReturnsProcessed {
    const message = createBaseWireHistoricalReturnsProcessed();
    message.monthRange = (object.monthRange !== undefined && object.monthRange !== null)
      ? WireMonthRange.fromPartial(object.monthRange)
      : undefined;
    message.stocks = (object.stocks !== undefined && object.stocks !== null)
      ? WireHistoricalMonthlyLogReturnsAdjustedInfo.fromPartial(object.stocks)
      : undefined;
    message.bonds = (object.bonds !== undefined && object.bonds !== null)
      ? WireHistoricalMonthlyLogReturnsAdjustedInfo.fromPartial(object.bonds)
      : undefined;
    return message;
  },
};

function createBaseWireReturnsStatsForPlanningProcessedPart(): WireReturnsStatsForPlanningProcessedPart {
  return { empiricalAnnualNonLogExpectedReturn: 0, empiricalAnnualLogVariance: 0 };
}

export const WireReturnsStatsForPlanningProcessedPart: MessageFns<WireReturnsStatsForPlanningProcessedPart> = {
  encode(message: WireReturnsStatsForPlanningProcessedPart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.empiricalAnnualNonLogExpectedReturn !== 0) {
      writer.uint32(9).double(message.empiricalAnnualNonLogExpectedReturn);
    }
    if (message.empiricalAnnualLogVariance !== 0) {
      writer.uint32(17).double(message.empiricalAnnualLogVariance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireReturnsStatsForPlanningProcessedPart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireReturnsStatsForPlanningProcessedPart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.empiricalAnnualNonLogExpectedReturn = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.empiricalAnnualLogVariance = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireReturnsStatsForPlanningProcessedPart {
    return {
      empiricalAnnualNonLogExpectedReturn: isSet(object.empiricalAnnualNonLogExpectedReturn)
        ? globalThis.Number(object.empiricalAnnualNonLogExpectedReturn)
        : 0,
      empiricalAnnualLogVariance: isSet(object.empiricalAnnualLogVariance)
        ? globalThis.Number(object.empiricalAnnualLogVariance)
        : 0,
    };
  },

  toJSON(message: WireReturnsStatsForPlanningProcessedPart): unknown {
    const obj: any = {};
    if (message.empiricalAnnualNonLogExpectedReturn !== 0) {
      obj.empiricalAnnualNonLogExpectedReturn = message.empiricalAnnualNonLogExpectedReturn;
    }
    if (message.empiricalAnnualLogVariance !== 0) {
      obj.empiricalAnnualLogVariance = message.empiricalAnnualLogVariance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireReturnsStatsForPlanningProcessedPart>, I>>(
    base?: I,
  ): WireReturnsStatsForPlanningProcessedPart {
    return WireReturnsStatsForPlanningProcessedPart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireReturnsStatsForPlanningProcessedPart>, I>>(
    object: I,
  ): WireReturnsStatsForPlanningProcessedPart {
    const message = createBaseWireReturnsStatsForPlanningProcessedPart();
    message.empiricalAnnualNonLogExpectedReturn = object.empiricalAnnualNonLogExpectedReturn ?? 0;
    message.empiricalAnnualLogVariance = object.empiricalAnnualLogVariance ?? 0;
    return message;
  },
};

function createBaseWireReturnsStatsForPlanningProcessed(): WireReturnsStatsForPlanningProcessed {
  return { stocks: undefined, bonds: undefined };
}

export const WireReturnsStatsForPlanningProcessed: MessageFns<WireReturnsStatsForPlanningProcessed> = {
  encode(message: WireReturnsStatsForPlanningProcessed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stocks !== undefined) {
      WireReturnsStatsForPlanningProcessedPart.encode(message.stocks, writer.uint32(10).fork()).join();
    }
    if (message.bonds !== undefined) {
      WireReturnsStatsForPlanningProcessedPart.encode(message.bonds, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireReturnsStatsForPlanningProcessed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireReturnsStatsForPlanningProcessed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stocks = WireReturnsStatsForPlanningProcessedPart.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bonds = WireReturnsStatsForPlanningProcessedPart.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireReturnsStatsForPlanningProcessed {
    return {
      stocks: isSet(object.stocks) ? WireReturnsStatsForPlanningProcessedPart.fromJSON(object.stocks) : undefined,
      bonds: isSet(object.bonds) ? WireReturnsStatsForPlanningProcessedPart.fromJSON(object.bonds) : undefined,
    };
  },

  toJSON(message: WireReturnsStatsForPlanningProcessed): unknown {
    const obj: any = {};
    if (message.stocks !== undefined) {
      obj.stocks = WireReturnsStatsForPlanningProcessedPart.toJSON(message.stocks);
    }
    if (message.bonds !== undefined) {
      obj.bonds = WireReturnsStatsForPlanningProcessedPart.toJSON(message.bonds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireReturnsStatsForPlanningProcessed>, I>>(
    base?: I,
  ): WireReturnsStatsForPlanningProcessed {
    return WireReturnsStatsForPlanningProcessed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireReturnsStatsForPlanningProcessed>, I>>(
    object: I,
  ): WireReturnsStatsForPlanningProcessed {
    const message = createBaseWireReturnsStatsForPlanningProcessed();
    message.stocks = (object.stocks !== undefined && object.stocks !== null)
      ? WireReturnsStatsForPlanningProcessedPart.fromPartial(object.stocks)
      : undefined;
    message.bonds = (object.bonds !== undefined && object.bonds !== null)
      ? WireReturnsStatsForPlanningProcessedPart.fromPartial(object.bonds)
      : undefined;
    return message;
  },
};

function createBaseWireAdjustmentsToSpendingProcessedTpawAndSpawLegacy(): WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy {
  return { external: 0, target: 0 };
}

export const WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy: MessageFns<
  WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy
> = {
  encode(
    message: WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.external !== 0) {
      writer.uint32(9).double(message.external);
    }
    if (message.target !== 0) {
      writer.uint32(17).double(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireAdjustmentsToSpendingProcessedTpawAndSpawLegacy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.external = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.target = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy {
    return {
      external: isSet(object.external) ? globalThis.Number(object.external) : 0,
      target: isSet(object.target) ? globalThis.Number(object.target) : 0,
    };
  },

  toJSON(message: WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy): unknown {
    const obj: any = {};
    if (message.external !== 0) {
      obj.external = message.external;
    }
    if (message.target !== 0) {
      obj.target = message.target;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy>, I>>(
    base?: I,
  ): WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy {
    return WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy>, I>>(
    object: I,
  ): WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy {
    const message = createBaseWireAdjustmentsToSpendingProcessedTpawAndSpawLegacy();
    message.external = object.external ?? 0;
    message.target = object.target ?? 0;
    return message;
  },
};

function createBaseWireAdjustmentsToSpendingProcessedTpawAndSpaw(): WireAdjustmentsToSpendingProcessedTpawAndSpaw {
  return { legacy: undefined };
}

export const WireAdjustmentsToSpendingProcessedTpawAndSpaw: MessageFns<WireAdjustmentsToSpendingProcessedTpawAndSpaw> =
  {
    encode(
      message: WireAdjustmentsToSpendingProcessedTpawAndSpaw,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.legacy !== undefined) {
        WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy.encode(message.legacy, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): WireAdjustmentsToSpendingProcessedTpawAndSpaw {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseWireAdjustmentsToSpendingProcessedTpawAndSpaw();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.legacy = WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): WireAdjustmentsToSpendingProcessedTpawAndSpaw {
      return {
        legacy: isSet(object.legacy)
          ? WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy.fromJSON(object.legacy)
          : undefined,
      };
    },

    toJSON(message: WireAdjustmentsToSpendingProcessedTpawAndSpaw): unknown {
      const obj: any = {};
      if (message.legacy !== undefined) {
        obj.legacy = WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy.toJSON(message.legacy);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<WireAdjustmentsToSpendingProcessedTpawAndSpaw>, I>>(
      base?: I,
    ): WireAdjustmentsToSpendingProcessedTpawAndSpaw {
      return WireAdjustmentsToSpendingProcessedTpawAndSpaw.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<WireAdjustmentsToSpendingProcessedTpawAndSpaw>, I>>(
      object: I,
    ): WireAdjustmentsToSpendingProcessedTpawAndSpaw {
      const message = createBaseWireAdjustmentsToSpendingProcessedTpawAndSpaw();
      message.legacy = (object.legacy !== undefined && object.legacy !== null)
        ? WireAdjustmentsToSpendingProcessedTpawAndSpawLegacy.fromPartial(object.legacy)
        : undefined;
      return message;
    },
  };

function createBaseWireAdjustmentsToSpendingProcessed(): WireAdjustmentsToSpendingProcessed {
  return { tpawAndSpaw: undefined };
}

export const WireAdjustmentsToSpendingProcessed: MessageFns<WireAdjustmentsToSpendingProcessed> = {
  encode(message: WireAdjustmentsToSpendingProcessed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tpawAndSpaw !== undefined) {
      WireAdjustmentsToSpendingProcessedTpawAndSpaw.encode(message.tpawAndSpaw, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireAdjustmentsToSpendingProcessed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireAdjustmentsToSpendingProcessed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tpawAndSpaw = WireAdjustmentsToSpendingProcessedTpawAndSpaw.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireAdjustmentsToSpendingProcessed {
    return {
      tpawAndSpaw: isSet(object.tpawAndSpaw)
        ? WireAdjustmentsToSpendingProcessedTpawAndSpaw.fromJSON(object.tpawAndSpaw)
        : undefined,
    };
  },

  toJSON(message: WireAdjustmentsToSpendingProcessed): unknown {
    const obj: any = {};
    if (message.tpawAndSpaw !== undefined) {
      obj.tpawAndSpaw = WireAdjustmentsToSpendingProcessedTpawAndSpaw.toJSON(message.tpawAndSpaw);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireAdjustmentsToSpendingProcessed>, I>>(
    base?: I,
  ): WireAdjustmentsToSpendingProcessed {
    return WireAdjustmentsToSpendingProcessed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireAdjustmentsToSpendingProcessed>, I>>(
    object: I,
  ): WireAdjustmentsToSpendingProcessed {
    const message = createBaseWireAdjustmentsToSpendingProcessed();
    message.tpawAndSpaw = (object.tpawAndSpaw !== undefined && object.tpawAndSpaw !== null)
      ? WireAdjustmentsToSpendingProcessedTpawAndSpaw.fromPartial(object.tpawAndSpaw)
      : undefined;
    return message;
  },
};

function createBaseWireRiskProcessedTpaw(): WireRiskProcessedTpaw {
  return {
    riskToleranceByMfn: [],
    rraUnclampedAt20IncludingPosInfinity: 0,
    rraUnclampedIncludingPosInfinityByMfn: [],
    legacyRraIncludingPosInfinity: 0,
  };
}

export const WireRiskProcessedTpaw: MessageFns<WireRiskProcessedTpaw> = {
  encode(message: WireRiskProcessedTpaw, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.riskToleranceByMfn) {
      writer.double(v);
    }
    writer.join();
    if (message.rraUnclampedAt20IncludingPosInfinity !== 0) {
      writer.uint32(17).double(message.rraUnclampedAt20IncludingPosInfinity);
    }
    writer.uint32(26).fork();
    for (const v of message.rraUnclampedIncludingPosInfinityByMfn) {
      writer.double(v);
    }
    writer.join();
    if (message.legacyRraIncludingPosInfinity !== 0) {
      writer.uint32(33).double(message.legacyRraIncludingPosInfinity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireRiskProcessedTpaw {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireRiskProcessedTpaw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 9) {
            message.riskToleranceByMfn.push(reader.double());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.riskToleranceByMfn.push(reader.double());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.rraUnclampedAt20IncludingPosInfinity = reader.double();
          continue;
        }
        case 3: {
          if (tag === 25) {
            message.rraUnclampedIncludingPosInfinityByMfn.push(reader.double());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rraUnclampedIncludingPosInfinityByMfn.push(reader.double());
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.legacyRraIncludingPosInfinity = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireRiskProcessedTpaw {
    return {
      riskToleranceByMfn: globalThis.Array.isArray(object?.riskToleranceByMfn)
        ? object.riskToleranceByMfn.map((e: any) => globalThis.Number(e))
        : [],
      rraUnclampedAt20IncludingPosInfinity: isSet(object.rraUnclampedAt20IncludingPosInfinity)
        ? globalThis.Number(object.rraUnclampedAt20IncludingPosInfinity)
        : 0,
      rraUnclampedIncludingPosInfinityByMfn: globalThis.Array.isArray(object?.rraUnclampedIncludingPosInfinityByMfn)
        ? object.rraUnclampedIncludingPosInfinityByMfn.map((e: any) => globalThis.Number(e))
        : [],
      legacyRraIncludingPosInfinity: isSet(object.legacyRraIncludingPosInfinity)
        ? globalThis.Number(object.legacyRraIncludingPosInfinity)
        : 0,
    };
  },

  toJSON(message: WireRiskProcessedTpaw): unknown {
    const obj: any = {};
    if (message.riskToleranceByMfn?.length) {
      obj.riskToleranceByMfn = message.riskToleranceByMfn;
    }
    if (message.rraUnclampedAt20IncludingPosInfinity !== 0) {
      obj.rraUnclampedAt20IncludingPosInfinity = message.rraUnclampedAt20IncludingPosInfinity;
    }
    if (message.rraUnclampedIncludingPosInfinityByMfn?.length) {
      obj.rraUnclampedIncludingPosInfinityByMfn = message.rraUnclampedIncludingPosInfinityByMfn;
    }
    if (message.legacyRraIncludingPosInfinity !== 0) {
      obj.legacyRraIncludingPosInfinity = message.legacyRraIncludingPosInfinity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireRiskProcessedTpaw>, I>>(base?: I): WireRiskProcessedTpaw {
    return WireRiskProcessedTpaw.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireRiskProcessedTpaw>, I>>(object: I): WireRiskProcessedTpaw {
    const message = createBaseWireRiskProcessedTpaw();
    message.riskToleranceByMfn = object.riskToleranceByMfn?.map((e) => e) || [];
    message.rraUnclampedAt20IncludingPosInfinity = object.rraUnclampedAt20IncludingPosInfinity ?? 0;
    message.rraUnclampedIncludingPosInfinityByMfn = object.rraUnclampedIncludingPosInfinityByMfn?.map((e) => e) || [];
    message.legacyRraIncludingPosInfinity = object.legacyRraIncludingPosInfinity ?? 0;
    return message;
  },
};

function createBaseWireRiskProcessed(): WireRiskProcessed {
  return { tpaw: undefined };
}

export const WireRiskProcessed: MessageFns<WireRiskProcessed> = {
  encode(message: WireRiskProcessed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tpaw !== undefined) {
      WireRiskProcessedTpaw.encode(message.tpaw, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WireRiskProcessed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWireRiskProcessed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tpaw = WireRiskProcessedTpaw.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WireRiskProcessed {
    return { tpaw: isSet(object.tpaw) ? WireRiskProcessedTpaw.fromJSON(object.tpaw) : undefined };
  },

  toJSON(message: WireRiskProcessed): unknown {
    const obj: any = {};
    if (message.tpaw !== undefined) {
      obj.tpaw = WireRiskProcessedTpaw.toJSON(message.tpaw);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WireRiskProcessed>, I>>(base?: I): WireRiskProcessed {
    return WireRiskProcessed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WireRiskProcessed>, I>>(object: I): WireRiskProcessed {
    const message = createBaseWireRiskProcessed();
    message.tpaw = (object.tpaw !== undefined && object.tpaw !== null)
      ? WireRiskProcessedTpaw.fromPartial(object.tpaw)
      : undefined;
    return message;
  },
};

function createBaseWirePlanParamsProcessed(): WirePlanParamsProcessed {
  return {
    marketDataForPresets: undefined,
    returnsStatsForPlanning: undefined,
    historicalReturns: undefined,
    amountTimed: undefined,
    adjustmentsToSpending: undefined,
    risk: undefined,
    annualInflation: 0,
  };
}

export const WirePlanParamsProcessed: MessageFns<WirePlanParamsProcessed> = {
  encode(message: WirePlanParamsProcessed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketDataForPresets !== undefined) {
      WireMarketDataForPresetsProcessed.encode(message.marketDataForPresets, writer.uint32(10).fork()).join();
    }
    if (message.returnsStatsForPlanning !== undefined) {
      WireReturnsStatsForPlanningProcessed.encode(message.returnsStatsForPlanning, writer.uint32(18).fork()).join();
    }
    if (message.historicalReturns !== undefined) {
      WireHistoricalReturnsProcessed.encode(message.historicalReturns, writer.uint32(26).fork()).join();
    }
    if (message.amountTimed !== undefined) {
      WireAmountTimedProcessed.encode(message.amountTimed, writer.uint32(34).fork()).join();
    }
    if (message.adjustmentsToSpending !== undefined) {
      WireAdjustmentsToSpendingProcessed.encode(message.adjustmentsToSpending, writer.uint32(42).fork()).join();
    }
    if (message.risk !== undefined) {
      WireRiskProcessed.encode(message.risk, writer.uint32(50).fork()).join();
    }
    if (message.annualInflation !== 0) {
      writer.uint32(57).double(message.annualInflation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WirePlanParamsProcessed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWirePlanParamsProcessed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.marketDataForPresets = WireMarketDataForPresetsProcessed.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.returnsStatsForPlanning = WireReturnsStatsForPlanningProcessed.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.historicalReturns = WireHistoricalReturnsProcessed.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amountTimed = WireAmountTimedProcessed.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.adjustmentsToSpending = WireAdjustmentsToSpendingProcessed.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.risk = WireRiskProcessed.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.annualInflation = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WirePlanParamsProcessed {
    return {
      marketDataForPresets: isSet(object.marketDataForPresets)
        ? WireMarketDataForPresetsProcessed.fromJSON(object.marketDataForPresets)
        : undefined,
      returnsStatsForPlanning: isSet(object.returnsStatsForPlanning)
        ? WireReturnsStatsForPlanningProcessed.fromJSON(object.returnsStatsForPlanning)
        : undefined,
      historicalReturns: isSet(object.historicalReturns)
        ? WireHistoricalReturnsProcessed.fromJSON(object.historicalReturns)
        : undefined,
      amountTimed: isSet(object.amountTimed) ? WireAmountTimedProcessed.fromJSON(object.amountTimed) : undefined,
      adjustmentsToSpending: isSet(object.adjustmentsToSpending)
        ? WireAdjustmentsToSpendingProcessed.fromJSON(object.adjustmentsToSpending)
        : undefined,
      risk: isSet(object.risk) ? WireRiskProcessed.fromJSON(object.risk) : undefined,
      annualInflation: isSet(object.annualInflation) ? globalThis.Number(object.annualInflation) : 0,
    };
  },

  toJSON(message: WirePlanParamsProcessed): unknown {
    const obj: any = {};
    if (message.marketDataForPresets !== undefined) {
      obj.marketDataForPresets = WireMarketDataForPresetsProcessed.toJSON(message.marketDataForPresets);
    }
    if (message.returnsStatsForPlanning !== undefined) {
      obj.returnsStatsForPlanning = WireReturnsStatsForPlanningProcessed.toJSON(message.returnsStatsForPlanning);
    }
    if (message.historicalReturns !== undefined) {
      obj.historicalReturns = WireHistoricalReturnsProcessed.toJSON(message.historicalReturns);
    }
    if (message.amountTimed !== undefined) {
      obj.amountTimed = WireAmountTimedProcessed.toJSON(message.amountTimed);
    }
    if (message.adjustmentsToSpending !== undefined) {
      obj.adjustmentsToSpending = WireAdjustmentsToSpendingProcessed.toJSON(message.adjustmentsToSpending);
    }
    if (message.risk !== undefined) {
      obj.risk = WireRiskProcessed.toJSON(message.risk);
    }
    if (message.annualInflation !== 0) {
      obj.annualInflation = message.annualInflation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WirePlanParamsProcessed>, I>>(base?: I): WirePlanParamsProcessed {
    return WirePlanParamsProcessed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WirePlanParamsProcessed>, I>>(object: I): WirePlanParamsProcessed {
    const message = createBaseWirePlanParamsProcessed();
    message.marketDataForPresets = (object.marketDataForPresets !== undefined && object.marketDataForPresets !== null)
      ? WireMarketDataForPresetsProcessed.fromPartial(object.marketDataForPresets)
      : undefined;
    message.returnsStatsForPlanning =
      (object.returnsStatsForPlanning !== undefined && object.returnsStatsForPlanning !== null)
        ? WireReturnsStatsForPlanningProcessed.fromPartial(object.returnsStatsForPlanning)
        : undefined;
    message.historicalReturns = (object.historicalReturns !== undefined && object.historicalReturns !== null)
      ? WireHistoricalReturnsProcessed.fromPartial(object.historicalReturns)
      : undefined;
    message.amountTimed = (object.amountTimed !== undefined && object.amountTimed !== null)
      ? WireAmountTimedProcessed.fromPartial(object.amountTimed)
      : undefined;
    message.adjustmentsToSpending =
      (object.adjustmentsToSpending !== undefined && object.adjustmentsToSpending !== null)
        ? WireAdjustmentsToSpendingProcessed.fromPartial(object.adjustmentsToSpending)
        : undefined;
    message.risk = (object.risk !== undefined && object.risk !== null)
      ? WireRiskProcessed.fromPartial(object.risk)
      : undefined;
    message.annualInflation = object.annualInflation ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
